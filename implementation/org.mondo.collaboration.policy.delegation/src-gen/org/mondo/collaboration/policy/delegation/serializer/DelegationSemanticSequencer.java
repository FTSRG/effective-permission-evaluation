/*
 * generated by Xtext 2.13.0
 */
package org.mondo.collaboration.policy.delegation.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.mondo.collaboration.policy.delegation.delegation.DelegationModel;
import org.mondo.collaboration.policy.delegation.delegation.DelegationPackage;
import org.mondo.collaboration.policy.delegation.delegation.Policy;
import org.mondo.collaboration.policy.delegation.delegation.Rule;
import org.mondo.collaboration.policy.delegation.services.DelegationGrammarAccess;
import org.mondo.collaboration.policy.rules.AccessControlModel;
import org.mondo.collaboration.policy.rules.AttributeFact;
import org.mondo.collaboration.policy.rules.Bind;
import org.mondo.collaboration.policy.rules.Binding;
import org.mondo.collaboration.policy.rules.Group;
import org.mondo.collaboration.policy.rules.Import;
import org.mondo.collaboration.policy.rules.ObjectFact;
import org.mondo.collaboration.policy.rules.ReferenceFact;
import org.mondo.collaboration.policy.rules.RulesPackage;
import org.mondo.collaboration.policy.rules.User;
import org.mondo.collaboration.policy.serializer.RulesSemanticSequencer;

@SuppressWarnings("all")
public class DelegationSemanticSequencer extends RulesSemanticSequencer {

	@Inject
	private DelegationGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == DelegationPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case DelegationPackage.DELEGATION_MODEL:
				sequence_DelegationModel(context, (DelegationModel) semanticObject); 
				return; 
			case DelegationPackage.POLICY:
				sequence_Policy(context, (Policy) semanticObject); 
				return; 
			case DelegationPackage.RULE:
				sequence_Rule(context, (Rule) semanticObject); 
				return; 
			}
		else if (epackage == RulesPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case RulesPackage.ACCESS_CONTROL_MODEL:
				sequence_AccessControlModel(context, (AccessControlModel) semanticObject); 
				return; 
			case RulesPackage.ATTRIBUTE_FACT:
				sequence_AttributeFact(context, (AttributeFact) semanticObject); 
				return; 
			case RulesPackage.BIND:
				sequence_Bind(context, (Bind) semanticObject); 
				return; 
			case RulesPackage.BINDING:
				sequence_Binding(context, (Binding) semanticObject); 
				return; 
			case RulesPackage.GROUP:
				sequence_Group(context, (Group) semanticObject); 
				return; 
			case RulesPackage.IMPORT:
				sequence_Import(context, (Import) semanticObject); 
				return; 
			case RulesPackage.OBJECT_FACT:
				sequence_ObjectFact(context, (ObjectFact) semanticObject); 
				return; 
			case RulesPackage.REFERENCE_FACT:
				sequence_ReferenceFact(context, (ReferenceFact) semanticObject); 
				return; 
			case RulesPackage.USER:
				sequence_User(context, (User) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     DelegationModel returns DelegationModel
	 *
	 * Constraint:
	 *     (import=Import policy=Policy)
	 */
	protected void sequence_DelegationModel(ISerializationContext context, DelegationModel semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DelegationPackage.Literals.DELEGATION_MODEL__IMPORT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DelegationPackage.Literals.DELEGATION_MODEL__IMPORT));
			if (transientValues.isValueTransient(semanticObject, DelegationPackage.Literals.DELEGATION_MODEL__POLICY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DelegationPackage.Literals.DELEGATION_MODEL__POLICY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDelegationModelAccess().getImportImportParserRuleCall_0_0(), semanticObject.getImport());
		feeder.accept(grammarAccess.getDelegationModelAccess().getPolicyPolicyParserRuleCall_1_0(), semanticObject.getPolicy());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Policy returns Policy
	 *
	 * Constraint:
	 *     (name=ID rules+=Rule* resolution=ResolutionType)
	 */
	protected void sequence_Policy(ISerializationContext context, Policy semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Rule returns Rule
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         access=AccessibilityLevel 
	 *         operation=OperationType? 
	 *         source=[Role|ID] 
	 *         targets+=[Role|ID] 
	 *         targets+=[Role|ID]* 
	 *         pattern=[Pattern|STRING] 
	 *         asset=ModelFact 
	 *         bindings+=Binding*
	 *     )
	 */
	protected void sequence_Rule(ISerializationContext context, Rule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
