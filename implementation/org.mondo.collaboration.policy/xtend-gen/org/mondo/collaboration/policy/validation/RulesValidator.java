/**
 * generated by Xtext 2.10.0
 */
package org.mondo.collaboration.policy.validation;

import com.google.common.base.Objects;
import org.eclipse.emf.ecore.EStructuralFeature;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.mondo.collaboration.policy.rules.AccessibilityLevel;
import org.mondo.collaboration.policy.rules.OperationType;
import org.mondo.collaboration.policy.rules.Policy;
import org.mondo.collaboration.policy.rules.ReferenceFact;
import org.mondo.collaboration.policy.rules.Rule;
import org.mondo.collaboration.policy.validation.AbstractRulesValidator;

/**
 * This class contains custom validation rules.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
@SuppressWarnings("all")
public class RulesValidator extends AbstractRulesValidator {
  public final static String INVALID_NAME = "invalidName";
  
  @Check
  public void checkPolicyOperation(final Policy policy) {
    final Function1<EStructuralFeature, Boolean> _function = (EStructuralFeature x) -> {
      return Boolean.valueOf(x.getName().equals("operation"));
    };
    final EStructuralFeature operation = IterableExtensions.<EStructuralFeature>findFirst(policy.eClass().getEAllStructuralFeatures(), _function);
    OperationType _operation = policy.getOperation();
    boolean _notEquals = (!Objects.equal(_operation, OperationType.READWRITE));
    if (_notEquals) {
      this.error("Both operation types have to be defined", policy, operation);
    }
  }
  
  @Check
  public void checkOperationTypeAfterObfuscate(final Rule rule) {
    final Function1<EStructuralFeature, Boolean> _function = (EStructuralFeature x) -> {
      return Boolean.valueOf(x.getName().equals("operation"));
    };
    final EStructuralFeature operation = IterableExtensions.<EStructuralFeature>findFirst(rule.eClass().getEAllStructuralFeatures(), _function);
    if ((Objects.equal(rule.getAccess(), AccessibilityLevel.OBFUSCATE) && (!Objects.equal(rule.getOperation(), OperationType.UNSET)))) {
      this.error("Operation type cannot be defined for obfuscation", rule, operation);
    }
  }
  
  @Check
  public void checkMissingOperationTypeAfterAllowDeny(final Rule rule) {
    final Function1<EStructuralFeature, Boolean> _function = (EStructuralFeature x) -> {
      return Boolean.valueOf(x.getName().equals("access"));
    };
    final EStructuralFeature access = IterableExtensions.<EStructuralFeature>findFirst(rule.eClass().getEAllStructuralFeatures(), _function);
    if (((Objects.equal(rule.getAccess(), AccessibilityLevel.ALLOW) || Objects.equal(rule.getAccess(), AccessibilityLevel.DENY)) && Objects.equal(rule.getOperation(), OperationType.UNSET))) {
      this.error("Missing operation type for accessibility level", rule, access);
    }
  }
  
  @Check
  public void checkObfuscateReference(final Rule rule) {
    final Function1<EStructuralFeature, Boolean> _function = (EStructuralFeature x) -> {
      return Boolean.valueOf(x.getName().equals("asset"));
    };
    final EStructuralFeature asset = IterableExtensions.<EStructuralFeature>findFirst(rule.eClass().getEAllStructuralFeatures(), _function);
    if ((Objects.equal(rule.getAccess(), AccessibilityLevel.OBFUSCATE) && (rule.getAsset() instanceof ReferenceFact))) {
      this.error("Reference asset cannot be obfuscated", rule, asset);
    }
  }
}
